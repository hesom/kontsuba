#include "exporter.h"
#include <iostream>
#include <fstream>
#include <tinyxml2.h>
#include <assimp/Exporter.hpp>
#include <assimp/SceneCombiner.h>
#include <tinyply.h>
#include <filesystem>

auto constructNode(tinyxml2::XMLDocument& doc, const std::string& type, const std::string name, const std::string& value){
    tinyxml2::XMLElement* node = doc.NewElement(type.c_str());
    node->SetAttribute("name", name.c_str());
    node->SetAttribute("value", value.c_str());
    return node;
}

void writeMeshPly(aiMesh* mesh, const std::string& filename){
    
    std::filebuf fb_binary;
    fb_binary.open(filename, std::ios::out | std::ios::binary);
    std::ostream outstream_binary(&fb_binary);
    if(outstream_binary.fail()){
        throw std::runtime_error("failed to open " + filename);
    }

    tinyply::PlyFile meshFile;
    std::cout << mesh->mNumVertices << std::endl;
    meshFile.add_properties_to_element("vertex", {"x", "y", "z"},
        tinyply::Type::FLOAT32, mesh->mNumVertices, reinterpret_cast<uint8_t*>(mesh->mVertices), tinyply::Type::INVALID, 0);

    if(mesh->HasNormals()){
        meshFile.add_properties_to_element("vertex", {"nx", "ny", "nz"},
            tinyply::Type::FLOAT32, mesh->mNumVertices, reinterpret_cast<uint8_t*>(mesh->mNormals), tinyply::Type::INVALID, 0);
    }
    
    if(mesh->HasTextureCoords(0)){
        meshFile.add_properties_to_element("vertex", {"u", "v"},
            tinyply::Type::FLOAT32, mesh->mNumVertices, reinterpret_cast<uint8_t*>(mesh->mTextureCoords[0]), tinyply::Type::INVALID, 0);
    }

    std::vector<unsigned int> indices;
    for(unsigned int i = 0; i < mesh->mNumFaces; i++){
        const aiFace& face = mesh->mFaces[i];
        auto numIndices = face.mNumIndices;
        if(numIndices != 3){
            throw std::runtime_error("only triangles are supported");
        }
        for(unsigned int j = 0; j < numIndices; j++){
            indices.push_back(face.mIndices[j]);
        }
    }
    meshFile.add_properties_to_element("face", {"vertex_indices"},
        tinyply::Type::UINT32, mesh->mNumFaces, reinterpret_cast<uint8_t*>(indices.data()), tinyply::Type::UINT8, 3);

    meshFile.get_comments().push_back("generated by kontsuba");
    meshFile.write(outstream_binary, true);
}

void exportScene(const aiScene* scene, const std::string& path)
{
    tinyxml2::XMLDocument doc;

    tinyxml2::XMLElement* root = doc.NewElement("scene");
    root->SetAttribute("version", "3.0.0");
    doc.InsertFirstChild(root);

    auto integratorNode = doc.NewElement("integrator");
    integratorNode->SetAttribute("type", "path");
    auto maxDepthNode = constructNode(doc, "integer", "max_depth", "3");
    integratorNode->InsertEndChild(maxDepthNode);
    root->InsertEndChild(integratorNode);

    auto sensorNode = doc.NewElement("sensor");
    sensorNode->SetAttribute("type", "perspective");
    auto fovNode = constructNode(doc, "float", "fov", "45");
    sensorNode->InsertEndChild(fovNode);
    auto toWorldNode = doc.NewElement("transform");
    toWorldNode->SetAttribute("name", "to_world");
    auto lookAtNode = doc.NewElement("lookat");
    lookAtNode->SetAttribute("origin", "1, 1, 0");
    lookAtNode->SetAttribute("target", "0, 0, 0");
    lookAtNode->SetAttribute("up", "0, 0, 1");
    toWorldNode->InsertEndChild(lookAtNode);
    sensorNode->InsertEndChild(toWorldNode);

    auto samplerNode = doc.NewElement("sampler");
    samplerNode->SetAttribute("type", "independent");
    auto sampleCountNode = constructNode(doc, "integer", "sample_count", "32");
    samplerNode->InsertEndChild(sampleCountNode);
    sensorNode->InsertEndChild(samplerNode);

    auto filmNode = doc.NewElement("film");
    filmNode->SetAttribute("type", "hdrfilm");
    auto widthNode = constructNode(doc, "integer", "width", "512");
    filmNode->InsertEndChild(widthNode);
    auto heightNode = constructNode(doc, "integer", "height", "512");
    filmNode->InsertEndChild(heightNode);
    auto pixelFormatNode = constructNode(doc, "string", "pixel_format", "rgb");
    filmNode->InsertEndChild(pixelFormatNode);
    sensorNode->InsertEndChild(filmNode);

    root->InsertEndChild(sensorNode);

    auto emitterNode = doc.NewElement("emitter");
    emitterNode->SetAttribute("type", "point");
    auto intensityNode = constructNode(doc, "rgb", "intensity", "10");
    emitterNode->InsertEndChild(intensityNode);
    auto positionNode = constructNode(doc, "point", "position", "2, 2, 2");
    emitterNode->InsertEndChild(positionNode);
    root->InsertEndChild(emitterNode);

    std::filesystem::create_directories(path);
    std::filesystem::create_directories(path + "/meshes");

    // loop over all materials in scene
    for(size_t i = 0; i < scene->mNumMaterials; i++){
        aiMaterial* material = scene->mMaterials[i];

        aiString name;
        material->Get(AI_MATKEY_NAME, name);
        int shadingModel;
        material->Get(AI_MATKEY_SHADING_MODEL, shadingModel);

        aiColor3D ka;
        material->Get(AI_MATKEY_COLOR_AMBIENT, ka);
        aiColor3D kd;
        material->Get(AI_MATKEY_COLOR_DIFFUSE, kd);
        aiColor3D ks;
        material->Get(AI_MATKEY_COLOR_SPECULAR, ks);
        float shininess;
        material->Get(AI_MATKEY_SHININESS, shininess);
        float opacity;
        material->Get(AI_MATKEY_OPACITY, opacity);
        float roughness;
        material->Get(AI_MATKEY_ROUGHNESS_FACTOR, roughness);
        float metallic;
        material->Get(AI_MATKEY_METALLIC_FACTOR, metallic);
        float sheenFactor;
        material->Get(AI_MATKEY_SHEEN_COLOR_FACTOR, sheenFactor);
        float anisotropy;
        material->Get(AI_MATKEY_ANISOTROPY_FACTOR, anisotropy);
        float clearCoat;
        material->Get(AI_MATKEY_CLEARCOAT_FACTOR, clearCoat);
        float clearCoatRoughness;
        material->Get(AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR, clearCoatRoughness);
        float specularFactor;
        material->Get(AI_MATKEY_SPECULAR_FACTOR, specularFactor);

        if(shadingModel != aiShadingMode_PBR_BRDF){
            // set reasonable defaults
            roughness = 0.5f;
            metallic = 0.0f;
            sheenFactor = 0.0f;
            anisotropy = 0.0f;
            clearCoat = 0.0f;
            clearCoatRoughness = 0.0f;
            specularFactor = 0.5f;
        }

        auto twoSidedNode = doc.NewElement("bsdf");
        twoSidedNode->SetAttribute("type", "twosided");
        auto materialNode = doc.NewElement("bsdf");
        materialNode->SetAttribute("type", "principled");
        twoSidedNode->SetAttribute("id", name.C_Str());
        auto baseColorNode = constructNode(doc, "rgb", "base_color", std::to_string(kd.r) + "," + std::to_string(kd.g) + "," + std::to_string(kd.b));
        materialNode->InsertEndChild(baseColorNode);
        auto roughnessNode = constructNode(doc, "float", "roughness", std::to_string(roughness));
        materialNode->InsertEndChild(roughnessNode);
        auto specularFactorNode = constructNode(doc, "float", "specular", std::to_string(specularFactor));
        materialNode->InsertEndChild(specularFactorNode);
        auto metallicNode = constructNode(doc, "float", "metallic", std::to_string(metallic));
        materialNode->InsertEndChild(metallicNode);
        auto sheenNode = constructNode(doc, "float", "sheen", std::to_string(sheenFactor));
        materialNode->InsertEndChild(sheenNode);
        auto anisotropyNode = constructNode(doc, "float", "anisotropic", std::to_string(anisotropy));
        materialNode->InsertEndChild(anisotropyNode);
        auto clearCoatNode = constructNode(doc, "float", "clearcoat", std::to_string(clearCoat));
        materialNode->InsertEndChild(clearCoatNode);
        auto clearCoatRoughnessNode = constructNode(doc, "float", "clearcoat_gloss", std::to_string(clearCoatRoughness));
        materialNode->InsertEndChild(clearCoatRoughnessNode);
        twoSidedNode->InsertEndChild(materialNode);
        root->InsertEndChild(twoSidedNode);
    }

    // loop over all meshes in scene
    for(size_t i = 0; i < scene->mNumMeshes; i++){
        aiMesh* mesh = scene->mMeshes[i];

        aiString name;
        std::string plyName = path + "/meshes/mesh" + std::to_string(i) + ".ply";
        scene->mMaterials[mesh->mMaterialIndex]->Get(AI_MATKEY_NAME, name);
        std::string plySceneFileName = "meshes/mesh" + std::to_string(i) + ".ply";

        auto meshNode = doc.NewElement("shape");
        meshNode->SetAttribute("type", "ply");
        auto filenameNode = constructNode(doc, "string", "filename", plySceneFileName.c_str());
        meshNode->InsertEndChild(filenameNode);
        auto refNode = doc.NewElement("ref");
        refNode->SetAttribute("id", name.C_Str());
        meshNode->InsertEndChild(refNode);

        root->InsertEndChild(meshNode);

        writeMeshPly(mesh, plyName);
    }

    std::string xmlPath = path + "/scene.xml";
    doc.SaveFile(xmlPath.c_str());
}