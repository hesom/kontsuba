#include "exporter.h"
#include <iostream>
#include <fstream>
#include <tinyxml2.h>
#include <assimp/Exporter.hpp>
#include <assimp/SceneCombiner.h>
#include <tinyply.h>
#include <filesystem>
#include <optional>
#include <random>

auto constructNode(tinyxml2::XMLDocument& doc, const std::string& type, const std::string name, const std::string& value){
    tinyxml2::XMLElement* node = doc.NewElement(type.c_str());
    node->SetAttribute("name", name.c_str());
    node->SetAttribute("value", value.c_str());
    return node;
}

auto probeMaterialTexture(const aiMaterial* material, aiTextureType type){
    aiString path;
    if(material->GetTextureCount(type) != 0){
        if(material->GetTexture(type, 0, &path) == aiReturn_SUCCESS){
            return std::optional<std::string>(path.C_Str());
        }
    }
    return std::optional<std::string>();
}

template<typename T>
auto probeMaterialProperty(const aiMaterial* material, const char* pKey, unsigned int type, unsigned int idx){
    T value;
    if(material->Get(pKey, type, idx, value) == aiReturn_SUCCESS){
        return std::optional<T>(value);
    }
    return std::optional<T>();
}

void writeMeshPly(aiMesh* mesh, const std::string& filename){
    
    std::filebuf fb_binary;
    fb_binary.open(filename, std::ios::out | std::ios::binary);
    std::ostream outstream_binary(&fb_binary);
    if(outstream_binary.fail()){
        throw std::runtime_error("failed to open " + filename);
    }

    tinyply::PlyFile meshFile;
    std::cout << mesh->mNumVertices << std::endl;
    meshFile.add_properties_to_element("vertex", {"x", "y", "z"},
        tinyply::Type::FLOAT32, mesh->mNumVertices, reinterpret_cast<uint8_t*>(mesh->mVertices), tinyply::Type::INVALID, 0);

    if(mesh->HasNormals()){
        meshFile.add_properties_to_element("vertex", {"nx", "ny", "nz"},
            tinyply::Type::FLOAT32, mesh->mNumVertices, reinterpret_cast<uint8_t*>(mesh->mNormals), tinyply::Type::INVALID, 0);
    }
    
    if(mesh->HasTextureCoords(0)){
        meshFile.add_properties_to_element("vertex", {"u", "v"},
            tinyply::Type::FLOAT32, mesh->mNumVertices, reinterpret_cast<uint8_t*>(mesh->mTextureCoords[0]), tinyply::Type::INVALID, 0);
    }

    std::vector<unsigned int> indices;
    for(unsigned int i = 0; i < mesh->mNumFaces; i++){
        const aiFace& face = mesh->mFaces[i];
        auto numIndices = face.mNumIndices;
        if(numIndices != 3){
            throw std::runtime_error("only triangles are supported");
        }
        for(unsigned int j = 0; j < numIndices; j++){
            indices.push_back(face.mIndices[j]);
        }
    }
    meshFile.add_properties_to_element("face", {"vertex_indices"},
        tinyply::Type::UINT32, mesh->mNumFaces, reinterpret_cast<uint8_t*>(indices.data()), tinyply::Type::UINT8, 3);

    meshFile.get_comments().push_back("generated by kontsuba");
    meshFile.write(outstream_binary, true);
}

void exportScene(const aiScene* scene, const std::string& path)
{
    tinyxml2::XMLDocument doc;

    tinyxml2::XMLElement* root = doc.NewElement("scene");
    root->SetAttribute("version", "3.0.0");
    doc.InsertFirstChild(root);

    auto integratorNode = doc.NewElement("integrator");
    integratorNode->SetAttribute("type", "path");
    auto maxDepthNode = constructNode(doc, "integer", "max_depth", "3");
    integratorNode->InsertEndChild(maxDepthNode);
    root->InsertEndChild(integratorNode);

    auto sensorNode = doc.NewElement("sensor");
    sensorNode->SetAttribute("type", "perspective");
    auto fovNode = constructNode(doc, "float", "fov", "45");
    sensorNode->InsertEndChild(fovNode);
    auto toWorldNode = doc.NewElement("transform");
    toWorldNode->SetAttribute("name", "to_world");
    auto lookAtNode = doc.NewElement("lookat");
    lookAtNode->SetAttribute("origin", "1, 1, 0");
    lookAtNode->SetAttribute("target", "0, 0, 0");
    lookAtNode->SetAttribute("up", "0, 0, 1");
    toWorldNode->InsertEndChild(lookAtNode);
    sensorNode->InsertEndChild(toWorldNode);

    auto samplerNode = doc.NewElement("sampler");
    samplerNode->SetAttribute("type", "independent");
    auto sampleCountNode = constructNode(doc, "integer", "sample_count", "32");
    samplerNode->InsertEndChild(sampleCountNode);
    sensorNode->InsertEndChild(samplerNode);

    auto filmNode = doc.NewElement("film");
    filmNode->SetAttribute("type", "hdrfilm");
    auto widthNode = constructNode(doc, "integer", "width", "512");
    filmNode->InsertEndChild(widthNode);
    auto heightNode = constructNode(doc, "integer", "height", "512");
    filmNode->InsertEndChild(heightNode);
    auto pixelFormatNode = constructNode(doc, "string", "pixel_format", "rgb");
    filmNode->InsertEndChild(pixelFormatNode);
    sensorNode->InsertEndChild(filmNode);

    root->InsertEndChild(sensorNode);

    auto emitterNode = doc.NewElement("emitter");
    emitterNode->SetAttribute("type", "point");
    auto intensityNode = constructNode(doc, "rgb", "intensity", "10");
    emitterNode->InsertEndChild(intensityNode);
    auto positionNode = constructNode(doc, "point", "position", "2, 2, 2");
    emitterNode->InsertEndChild(positionNode);
    root->InsertEndChild(emitterNode);

    std::filesystem::create_directories(path);
    std::filesystem::create_directories(path + "/meshes");

    // loop over all materials in scene
    for(size_t i = 0; i < scene->mNumMaterials; i++){
        aiMaterial* material = scene->mMaterials[i];

        // set name to random number if not available because it is used as id
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<uint32_t> dis(0, std::numeric_limits<uint32_t>::max());
        auto guid = dis(gen);

        auto name = probeMaterialProperty<aiString>(material, AI_MATKEY_NAME).value_or(aiString(std::to_string(guid)));
        auto shadingModel = probeMaterialProperty<int>(material, AI_MATKEY_SHADING_MODEL).value_or(aiShadingMode_Phong);

        // Get all possble material bsdf properties and set to default if not available
        // clang-format off
        auto ka =                   probeMaterialProperty<aiColor3D>(material, AI_MATKEY_COLOR_AMBIENT).value_or(aiColor3D(0.0f, 0.0f, 0.0f));
        auto kd =                   probeMaterialProperty<aiColor3D>(material, AI_MATKEY_COLOR_DIFFUSE).value_or(aiColor3D(0.0f, 0.0f, 0.0f));
        auto ks =                   probeMaterialProperty<aiColor3D>(material, AI_MATKEY_COLOR_SPECULAR).value_or(aiColor3D(0.0f, 0.0f, 0.0f));
        auto baseColor =            probeMaterialProperty<aiColor3D>(material, AI_MATKEY_BASE_COLOR).value_or(kd);
        auto shininess =            probeMaterialProperty<float>(material, AI_MATKEY_SHININESS).value_or(1.0f);
        auto opacity =              probeMaterialProperty<float>(material, AI_MATKEY_OPACITY).value_or(1.0f);
        auto roughness =            probeMaterialProperty<float>(material, AI_MATKEY_ROUGHNESS_FACTOR).value_or(0.5f);
        auto metallic =             probeMaterialProperty<float>(material, AI_MATKEY_METALLIC_FACTOR).value_or(0.0f);
        auto sheenFactor =          probeMaterialProperty<float>(material, AI_MATKEY_SHEEN_COLOR_FACTOR).value_or(0.0f);
        auto anisotropy =           probeMaterialProperty<float>(material, AI_MATKEY_ANISOTROPY_FACTOR).value_or(0.0f);
        auto clearCoat =            probeMaterialProperty<float>(material, AI_MATKEY_CLEARCOAT_FACTOR).value_or(0.0f);
        auto clearCoatRoughness =   probeMaterialProperty<float>(material, AI_MATKEY_CLEARCOAT_ROUGHNESS_FACTOR).value_or(0.0f);
        auto specularFactor =       probeMaterialProperty<float>(material, AI_MATKEY_SPECULAR_FACTOR).value_or(0.5f);

        // Get all possible texture paths (these are all optional)
        auto diffuseTexture =       probeMaterialTexture(material, aiTextureType_DIFFUSE);
        auto metallicTexture =      probeMaterialTexture(material, aiTextureType_METALNESS);
        auto roughnessTexture =     probeMaterialTexture(material, aiTextureType_DIFFUSE_ROUGHNESS);
        auto normalTexture =        probeMaterialTexture(material, aiTextureType_NORMALS);
        auto displacementTexture =  probeMaterialTexture(material, aiTextureType_DISPLACEMENT);
        auto occlusionTexture =     probeMaterialTexture(material, aiTextureType_AMBIENT_OCCLUSION);
        auto emissiveTexture =      probeMaterialTexture(material, aiTextureType_EMISSIVE);
        // clang-format on

        if(shadingModel != aiShadingMode_PBR_BRDF){
            // set reasonable defaults, because other values cannot be trusted
            roughness = 0.5f;
            metallic = 0.0f;
            sheenFactor = 0.0f;
            anisotropy = 0.0f;
            clearCoat = 0.0f;
            clearCoatRoughness = 0.0f;
            specularFactor = 0.5f;
        }

        auto twoSidedNode = doc.NewElement("bsdf");
        twoSidedNode->SetAttribute("type", "twosided");
        auto materialNode = doc.NewElement("bsdf");
        materialNode->SetAttribute("type", "principled");
        twoSidedNode->SetAttribute("id", name.C_Str());
        auto baseColorNode = constructNode(doc, "rgb", "base_color", std::to_string(baseColor.r) + "," + std::to_string(baseColor.g) + "," + std::to_string(baseColor.b));
        materialNode->InsertEndChild(baseColorNode);
        auto roughnessNode = constructNode(doc, "float", "roughness", std::to_string(roughness));
        materialNode->InsertEndChild(roughnessNode);
        auto specularFactorNode = constructNode(doc, "float", "specular", std::to_string(specularFactor));
        materialNode->InsertEndChild(specularFactorNode);
        auto metallicNode = constructNode(doc, "float", "metallic", std::to_string(metallic));
        materialNode->InsertEndChild(metallicNode);
        auto sheenNode = constructNode(doc, "float", "sheen", std::to_string(sheenFactor));
        materialNode->InsertEndChild(sheenNode);
        auto anisotropyNode = constructNode(doc, "float", "anisotropic", std::to_string(anisotropy));
        materialNode->InsertEndChild(anisotropyNode);
        auto clearCoatNode = constructNode(doc, "float", "clearcoat", std::to_string(clearCoat));
        materialNode->InsertEndChild(clearCoatNode);
        auto clearCoatRoughnessNode = constructNode(doc, "float", "clearcoat_gloss", std::to_string(clearCoatRoughness));
        materialNode->InsertEndChild(clearCoatRoughnessNode);
        twoSidedNode->InsertEndChild(materialNode);
        root->InsertEndChild(twoSidedNode);
    }

    // loop over all meshes in scene
    for(size_t i = 0; i < scene->mNumMeshes; i++){
        aiMesh* mesh = scene->mMeshes[i];

        aiString name;
        std::string plyName = path + "/meshes/mesh" + std::to_string(i) + ".ply";
        scene->mMaterials[mesh->mMaterialIndex]->Get(AI_MATKEY_NAME, name);
        std::string plySceneFileName = "meshes/mesh" + std::to_string(i) + ".ply";

        auto meshNode = doc.NewElement("shape");
        meshNode->SetAttribute("type", "ply");
        auto filenameNode = constructNode(doc, "string", "filename", plySceneFileName.c_str());
        meshNode->InsertEndChild(filenameNode);
        auto refNode = doc.NewElement("ref");
        refNode->SetAttribute("id", name.C_Str());
        meshNode->InsertEndChild(refNode);

        root->InsertEndChild(meshNode);

        writeMeshPly(mesh, plyName);
    }

    std::string xmlPath = path + "/scene.xml";
    doc.SaveFile(xmlPath.c_str());
}